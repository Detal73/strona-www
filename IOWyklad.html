<html lang="pl">

<head>
  <meta charset="UTF-8">
	<title>IO Wykład</title>
	<style>

	body{
		margin: 40px auto;
		max-width: 650px;
		line-height: 1.6;
		font-size: 18px;
		color: #444;
		padding: 0 10 px;
		background-color: #EEEEEE;
	}

	h1, h2, h3 {
		line-height: 1.2;
	}
	</style>
</head>


<body>

	<p>
	<h3>1) Oprogramowanie to:  </h3>
	programy komputerowe, cała związana z nim dokumentacja i dane konfiguracyjne  <br>
	</p>

	<p>
	<h3>2) Produkty oprogramowania w inżynierii oprogramowania można podzielić na:  </h3>
	powszechne – sprzedawane na wolnym rynku  <br>
	dostosowane – wykonywane na zamówienie  <br>
	</p>

	<p>
	<h3>3) W procesie wytwarzania oprogramowania nigdy nie występuje etap:  </h3>
	fizycznego konstruowania oprogramowania  <br>
	zdolność do ewolucji zgodnie z potrzebami klientów (rozbudowa programu)  <br>
	</p>

	<p>
	<h3>5) Niezawodność jest cechą oprogramowania oznaczającą:  </h3>
	nie powinno powodować fizycznych lub ekonomicznych katastrof w przypadku awari  <br>
	</p>

	<p>
	<h3>nie powinno marnować się zasobów systemu (pamięć , czas procesora) </h3>
	</p>

	<p>
	<h3>7) Inżynieria oprogramowania to:  </h3>
	dziedzina inżynierii która obejmuje wszystkie aspekty tworzenia oprogramowania od fazy początkowej do jego pielęgnacji  <br>
	</p>

	<p>
	<h3>8) Proces tworzenia oprogramowania to:  </h3>
	zbiór czynności i związanych z nim wyników, które zmierzają do opracowania produktu programowego   <br>
	</p>

	<p>
	<h3>9) Czynności wspólne dla wszystkich procesów inżynierii oprogramowania:  </h3>
	*specyfikacja oprogramowania    <br>
	*tworzenie oprogramowania   <br>
	*zatwierdzanie oprogramowania  <br>
	*ewolucja oprogramowania   <br>
	</p>

	<p>
	<h3>10) Model procesu tworzenia oprogramowania to:  </h3>
	uproszczona prezentacja procesu tworzenia oprogramowania, modele ze swej natury są uproszczeniami  <br>
	</p>

	<p>
	<h3>11) Przykłady modeli tworzenia oprogramowania to:  </h3>
	*model kaskadowy  <br>
	*model oparty na prototypie  <br>
	*programowanie odkrywcze  <br>
	*realizacja przyrostowa  <br>
	*montaż z gotowych elementów  <br>
	*model spiralny  <br>
	</p>

	<p>
	<h3>12) Wadą modelu kaskadowego jest:  </h3>
	*wysokie koszty błędów we wstępnych fazach  <br>
	*długa przerwa w kontaktach z klientem  <br>
	*ścisła kolejność wykonywanych prac <br>
	</p>

	<p>
	<h3>13) Wadą modelu opartego na prototypowaniu jest:  </h3>
	*dodatkowy koszt budowy prototypu  <br>
	*konieczność oczekiwania na końcowy system po akceptacji prototypu  <br>
	</p>

	<p>
	<h3>14) Zaletą modelu opartego na prototypowaniu jest:  </h3>
	*lepsze określenie wymagań klienta  <br>
	*szybsza demonstracja pracującej wersji systemu  <br>
	*możliwość szkoleń zanim zostanie zbudowany pełny system  <br>
	</p>

	<p>
	<h3>15) Skrót CASE oznacza:  </h3>
	programy wykorzystywane do wspomagania czynności procesu tworzenia oprogramowania  <br>
	</p>

	<p>
	<h3>16) Wymagania stawiane systemowi komputerowemu to:  </h3>
	*opis usług i ograniczeń  <br>
	</p>

	<p>
	<h3>17) Proces inżynierii wymagań to:  </h3>
	wynajdowania, analizowania, dokumentowania  <br>
	</p>

	<p>
	<h3>18) Wymagania użytkownika to:  </h3>
	wyrażenia w języku naturalnym oraz diagramy o usługach oczekiwanych od systemu oraz o ograniczeniach  <br>
	</p>

	<p>
	<h3>19) Wymagania systemowe:  </h3>
	szczegółowo ustalają usługi systemu i ograniczenia i ograniczenia. Dokumentacja wymagań systemowych zwana czasem specyfikacją funkcjonalną powinna być precyzyjna  <br>
	</p>

	<p>
	<h3>20) Specyfikacja projektu to:  </h3>
	abstrakcyjny opis projektu oprogramowania, który jest podstawą bardziej szczegółowego projektu i implementacji  <br>
	</p>

	<p>
	<h3>21) Wymagania funkcjonalne:  </h3>
	jakie usługi ma oferować system, jak ma reagować na określone dane wejściowe , oraz jak ma się zachowywać w określonych sytuacjach.  <br>
	</p>

	<p>
	<h3>22) Wymaganie niefunkcjonalne to:  </h3>
	ograniczenia usług i funkcji systemu. Obejmują czasowe ograniczenia dotyczące procesu tworzenia, standardy  <br>
	</p>

	<p>
	<h3>23) Wymagania dziedzinowe:  </h3>
	pochodzą od dziedziny zastosowań systemu, odzwierciedlają jej charakterystykę. Mogą być funkcjonalne lub niefunkcjonalne  <br>
	*wymagania organizacyjne (wynikają ze strategii i procedur w firmie klienta)  <br>
	*wymagania zewnętrzne   <br>
	</p>

	<p>
	<h3>25) Uczestnik w analizie wymagań:  </h3>
	osoba która będzie pracować z systemem oraz osoby na które system będzie miał wpływ. Uczestnik powinien mieć bezpośredni i pośredni wpływ na wymagania systemowe.  <br>
	</p>

	<p>
	<h3>26) Studium wykonalności odpowiada na pytanie:  </h3>
	*czy system przyczyni się do realizacji celów przedsiębiorstwa?  <br>
	*czy system może być zaimplementowany z użyciem dostępnych technologii w ramach ustalonego budżetu i ograniczeń czasowych?  <br>
	*czy system może być zintegrowany z istniejącymi systemami, które już zainstalowano?  <br>
	</p>

	<p>
	<h3>27) Skrót UML w inżynierii oprogramowania oznacza:  </h3>
	Unifiled Modeling Language <br>
	*ujednolicony – można go współdzielić z wieloma pracownikami  <br>
	*język – posiada opisaną strukturę  <br>
	*modelowania – służy do opisu projektu modelu  <br>
	OMT (Object Modeling Technique) – James Rumbaugh  <br>
	*przypadków użycia (zawiera wszystkie wyżej)  <br>
	</p>

	<p>
	<h3>30) Diagramy UML można ogólnie podzielić na:  </h3>
	dynamiczne, statyczne  <br>
	</p>

	<p>
	<h3>31) Elementami składowymi UML są:  </h3>
	elementy, związki, diagramy  <br>
	</p>

	<p>
	<h3>32) Stereotyp w UML jest symbolizowany przez i oznacza:  </h3>
	sygnalizuje specjalne użycie np.  ludzik oznacza KLIENTA   <br>
	</p>

	<p>
	<h3>33) Przypadek użycia odpowiada wymaganiom:  </h3>
	funkcjonalnym  <br>
	</p>

	<p>
	<h3>34) Przypadek użycia to:  </h3>
	kompletne wykorzystanie systemu , które składa się z interakcji użytkownika z systemem i rezultaty powinien mieć zdefiniowane kryteria powodzenia i niepowodzenia  <br>
	</p>

	<p>
	<h3>35) W modelowaniu wymagań, aktorów należy traktować jako:  </h3>
	nierzeczywistych ludzi, mogą być czarnymi skrzynkami. Aktorzy muszą współdziałać z systemem  <br>
	uogólnienia inaczej:(generalizacja lub dziedziczenie) co powoduje hierarchizacje aktorów  <br>
	</p>

	<p>
	<h3>37) Na diagramie przypadków użycia linia komunikacji:  </h3>
	oznacza komunikacje między aktorem a przypadkiem użycia  <br>
	</p>

	<p>
	<h3>38) Pomiędzy przypadkami użycia mogą zachodzić relacje:  </h3>
	A<<include>> B  -przypadek A wielokrotnie używa przypadku B  <br>
	A<<extend>>B – przypadek A czasami używa przypadku B  <br>
	</p>

	<p>
	<h3>39) Diagram czynności UML umożliwia:  </h3>
	pokazanie w jaki sposób system osiąga zamierzone cele  <br>
	</p>

	<p>
	<h3>40) Na diagramie czynności UML:  </h3>
	pokazane są interakcje  z zewnętrznymi uczestnikami   <br>
	</p>

	<p>
	<h3>41) Diagram sekwencji UML umożliwia:  </h3>
	przedstawienie kolejności interakcji pomiędzy uczestnikami  <br>
	</p>

	<p>
	<h3>42) Każdy uczestnik na diagramie sekwencji UML posiada:  </h3>
	linie życia  <br>
	</p>

	<p>
	<h3>43) Wywołanie metody danego uczestnika to inaczej:  </h3>
	wysłanie komunikatu <br>
	</p>

	<p>
	<h3>44) Wysłanie komunikatu synchronicznego powoduje, że:  </h3>
	obiekt wysyłający oczekuje komunikatu zwrotnego by ponownie wysłać komunikat  <br>
	</p>

	<p>
	<h3>45) Wysłanie komunikatu asynchronicznego powoduje, że:  </h3>
	komunikat powraca z wywołania procedury, może być pomijany  <br>
	atrybut klasy (dane)  <br>
	</p>

	<p>
	<h3>47) Zachowanie klasy to:  </h3>
	operacje jakie klasa może wykonać   <br>
	</p>

	<p>
	<h3>48) Diagram klas prezentuje:  </h3>
	typy obiektów w programie   <br>
	</p>

	<p>
	<h3>49) Instancją danej klasy nazywa się:  </h3>
	obiekty danej klasy  <br>
	</p>

	<p>
	<h3>50) Hermetyzacja umożliwia:  </h3>
	ukrywanie szczegółów implementacji klasy  <br>
	</p>

	<p>
	<h3>51) Hermetyzacja oznacza, że:  </h3>
	obiekt powinien zawierać dane i instrukcje  <br>
	prostokąt z nazwą klasy oraz opcjonalnie jej atrybuty oraz operacje(metody)  <br>
	(+)elementy danej klasy są widoczne dla każdego  <br>
	(#)elementy danej klasy są widoczne dla swojej klasy i klas które po niej dziedziczą  <br>
	(-)elementy danej klasy są widoczne tylko w swojej klasie  <br>
	</p>

	<p>
	<h3>55) Poziomy dostępu wymienione od najmniej restrykcyjnego do najbardziej restrykcyjnego poziomu to:  </h3>
	publiczny – chroniony- pakietowy-prywatny  <br>
	</p>

	<p>
	<h3>56) Poziomu dostępu wymienione od najbardziej restrykcyjnego do najmniej restrykcyjnego poziomu:  </h3>
	prywatny-pakietowy-chroniony-publiczny  <br>
	</p>

	<p>
	<h3>57) Liczebność w oznaczeniu związku 1..* przy danej klasie oznacza, że:  </h3>
	obiekt klasy X może przechowywać od 1 do nieskończonej liczby obiektów klasy Y w kontenerze  <br>
	</p>

	<p>
	<h3>58) +addEntry(): void jako opis operacji klasy oznacza, że:  </h3>
	publiczna poziom dostępu do metody addEntry bez parametru i zwraca tym VOID  <br>
	zależność-asocjacja-agregacja-kompozycja-dziedziczenie(generalizacja)  <br>
	dziedziczenie(generalizacja)-kompozycja- agregacja-asocjacja-zależność  <br>
	</p>
	<p>
	<h3>59) Związki pomiędzy klasami od najsłabszego do najsilniejszego:  </h3>
	zależność-asocjacja-agregacja-kompozycja-dziedziczenie(generalizacja) <br>
	</p>

	<p>
	<h3>60) Związki pomiędzy klasami od najsilniejszego do najsłabszego:  </h3>
	dziedziczenie(generalizacja)-kompozycja- agregacja-asocjacja-zależność <br>
	</p>

	<p>
	<h3>61) Związek zależności oznacza, że:  </h3>
	gdy obiekty jednej klasy działają wykorzystując przelotnie obiekty innej klasy  <br>
	</p>

	<p>
	<h3>62) Związek asocjacji oznacza, że:  </h3>
	gdy obiekty jednej klasy działają wykorzystując obiekty innej klasy przez dłuższą chwile  <br>
	</p>

	<p>
	<h3>63) Związek agregacji oznacza, że:  </h3>
	klasa zawiera, ale jednocześnie współdzieli odwołanie do obiektów innej <br>
	</p>

	<p>
	<h3>64) Związek kompozycji oznacza, że:  </h3>
	klasa zawiera obiekty innej  <br>
	</p>

	<p>
	<h3>65) Związek dziedziczenia oznacza, że:  </h3>
	jedna klasa jest rodzajem innej  <br>
	</p>

	<p>
	<h3>66) Klasa abstrakcyjna to:  </h3>
	klasa która nie ma swoich obiektów  <br>
	</p>

	<p>
	<h3>67) Wyrażenie 'zmienna <> 2' w języku OCL oznacza:  </h3>
	zmienna ma wartość różną od 2  <br>
	</p>

	<p>
	<h3>68) Ograniczenie 'pre:x>0' nałożone na metodę 'f(x:int): int' oznacza:  </h3>
	parametr x funkcji f musi być większy od 0  <br>
	</p>

	<p>
	<h3>69) Na diagramie obiektów UML przedstawia się:  </h3>
	instancje obiektów i połączenie między nimi  <br>
	</p>

	<p>
	<h3>70) Dwa obiekty na diagramie obiektów mogą być połączone ze sobą, gdy:  </h3>
	występuje asocjacja lub agregacja  <br>
	</p>

	<p>
	<h3>71) Port w języku UML służy do:  </h3>
	komunikacji obiektów z otoczeniem, porty używane są do grupowania podobnych interfesjów  <br>
	</p>

	<p>
	<h3>72) Komponent to: </h3>
	hermetyzowana , możliwa do powtórnego użycia część oprogramowania   <br>
	</p>

	<p>
	<h3>73) Diagram komponentów UML umożliwia:  </h3>
	łatwe modelowanie architektury systemu  <br>
	</p>

	<p>
	<h3>74) Pakiety w języku UML służą do:  </h3>
	łączą w grupy elementy które są podobne, mogą grupować podobne przypadki użycia  <br>
	</p>

	<p>
	<h3>75) Na diagramach komunikacji UML przedstawia się:  </h3>
	połączenia wymagane do przekazania komunikatów  <br>
	</p>

	<p>
	<h3>76) Kolejność wywołania komunikatów na diagramach komunikacji UML jest odczytywana dzięki:  </h3>
	numeracji komunikatów  <br>
	</p>

	<p>
	<h3>77) Kolejność wywołania komunikatów na diagramach sekwencji UML jest odczytywana dzięki:  </h3>
	osi czasu  <br>
	</p>

	<p>
	<h3>78) Charakterystyczną cechą diagramu czasowego UML jest:  </h3>
	ukazują zależności czasowe, przedstawiają widok procesu  <br>
	</p>

	<p>
	<h3>79) Na przeglądowym diagramie interakcji UML znaleźć się mogą:  </h3>
	*diagram czynności  <br>
	*diagram interakcji  <br>
	*diagram komunikacji  <br>
	*diagram czasowy  <br>
	</p>

	<p>
	<h3>80) Diagram maszyny stanowej UML przedstawia:  </h3>
	stan obiektu i zachodzące w nim zmiany  <br>
	</p>

	<p>
	<h3>81) Na diagramie maszyny stanowej UML zmiana stanu obiektu spowodowana jest:  </h3>
	użyciem wyzwalacza  <br>
	</p>

	<p>
	<h3>82) Stan nieaktywny na diagramie stanów UML to:  </h3>
	obiekt z którego wychodzimy  <br>
	</p>

	<p>
	<h3>83) Diagram wdrożenia UML przedstawia: </h3>
	widok fizyczny, jak wdrażane są programy na sprzęcie   <br>
	pliki (wykonywalne, biblioteczne, źródłowe, konfiguracyjne)<br>
	</p>

	<p>
	<h3>85) Węzły na diagramie wdrożenia UML to: </h3>
	programowy lub sprzętowy zasób, który może zawierać oprogramowanie lub powiązane z nim pliki   <br>
	komunikacja (odczyt, zapis…) <br>
	</p>

	<p>
	<h3>87) W modelowaniu CRC taka cecha klasy jak materialność oznacza:  </h3>
	w klasie istnieje obiekt potrafiący wykonać zadanie  <br>
	</p>

	<p>
	<h3>88) W modelowaniu CRC taka cecha klasy jak inkluzywność oznacza:  </h3>
	że klasa jest atomowa, jeśli nie zawiera ona innych klas oraz połączeń  <br>
	</p>

	<p>
	<h3>89) W modelowaniu CRC taka cecha klasy jak sekwencyjność oznacza:  </h3>
	nie można przeskakiwać o kilka zadań, trzeba je wykonywać po kolei   <br>
	</p>

	<p>
	<h3>90) W modelowaniu CRC taka cecha klasy jak trwałość oznacza:  </h3>
	zawartość się nie zmieni  <br>
	</p>

	<p>
	<h3>91) W modelowaniu CRC taka cecha klasy jak integralność oznacza:  </h3>
	że klasę można wykorzystać w przyszłości do innych celów  <br>
	</p>

	<p>
	<h3>92) Architektura systemu komputerowego określa: </h3>
	strukturę połączeń jego składników programowych , widoczne cechy tych składników i połączenia jakie między nimi zachodzą  <br>
	całość aplikacji jest wykonywana w ramach jednego systemu operacyjnego lub zbioru zasobów , komponenty mogą komunikować się ze sobą na zasadzie każdy z każdym z pominięciem warstw(komunikacja tylko z warstwą nadrzędną lub podrzędną) <br>
	</p>

	<p>
	<h3>94) Architektura obiektowa systemu oznacza, że:  </h3>
	Model obiektowy architektury systemu dzieli system na zbiór luźno uzależnionych od siebie obiektów z dobrze zdefiniowanymi interfejsami. Obiekty korzystają z usług oferowanych przez inne obiekty. Podział obiektowy uwzględnia klasy obiektów, ich atrybuty i operacje.  <br>
	</p>

	<p>
	<h3>95) Architektura systemu oparta na przepływie danych oznacza, że:  </h3>
	wykorzystuje się do modelowania funkcji pod kątem przekazywania danych między procesami i innymi obiektami. Pozwalają zaznaczyć w modelu, na wielu poziomach szczegółowości, obecność rozpoznanych funkcji użytkowych oraz z jakich danych korzysta każda z wprowadzonych na diagram funkcji. Diagramy przepływu danych to narzędzie analizy i projektowania systemów, zwłaszcza w odniesieniu do systemów transakcyjnych  <br>
	</p>

	<p>
	<h3>96) Architektura wywołań i powrotów oznacza, że:  </h3>
	w modelu podprogramów sterowanie zaczyna się od wierzchołka hierarchii podprogramów i poprzez odwołania podprogramów przechodzi do niższych poziomów drzewa  <br>
	</p>

	<p>
	<h3>97) Minimalny opis wzorca składa się z:  </h3>
	*nazwy wzorca  <br>
	*rozwiązanego problemu  <br>
	*rozwiązania  <br>
	*konsekwencji  <br>
	</p>

	<p>
	<h3>98) Wzorce projektowe w Inżynierii Oprogramowania dzieli się na:  </h3>
	*to co robią  <br>
	*ich zakres   <br>
	</p>

	<p>
	<h3>99) Wzorce projektowe w Inżynierii Oprogramowania dzieli się na:  </h3>
	*to co robią kreacyjne/strukturalne/czynnościowe <br>
	*ich zakres  klasowe/obiektowe  <br>
	</p>

	<p>
	<h3>100) Przeznaczeniem wzorca projektowego Adapter jest: </h3>
	przekształca interfejs klasy na taki jakiego klienci oczekują   <br>
	</p>

	<p>
	<h3>101) Uczestnikami wzorca projektowego Adapter są:  </h3>
	*cel  <br>
	*klient  <br>
	*adaptowany  <br>
	*adapter  <br>
	</p>

	<p>
	<h3>103) Uczestnikami wzorca projektowego Obserwator są:  </h3>
	*obserwator  <br>
	*obserwator konkretny  <br>
	*obserwowany  <br>
	*obserwowany konkrenty  <br>
	</p>

	<p>
	<h3>104) Przeznaczeniem wzorca projektowego Strategia jest:  </h3>
	umożliwienie zmiany algorytmu niezależnie od użytkujących go klientów  <br>
	</p>

	<p>
	<h3>105) Uczestnikami wzorca projektowego Strategia są:  </h3>
	*kontekst  <br>
	*strategia  <br>
	*strategiaKonkretna  <br>
	</p>

	<p>
	<h3>106) Przeznaczeniem wzorca projektowego Kompozyt jest:  </h3>
	składa obiekty w struktury drzewiaste, reprezentujące hierarchię typu część-całość  <br>
	</p>

	<p>
	<h3>107) Uczestnikami wzorca projektowego Kompozyt są:  </h3>
	*kompozyt  <br>
	*klient  <br>
	*komponent  <br>
	*klient  <br>
	</p>

	<p>
	<h3>108) Przeznaczeniem wzorca projektowego Iterator jest:  </h3>
	Wzorzec zapewnia sekwencyjny dostęp do elementów obiektu zagregowanego bez ujawniania jego reprezentacji wewnętrznej.  <br>
	</p>

	<p>
	<h3>109) Uczestnikami wzorca projektowego Iterator są:  </h3>
	*iterator  <br>
	* iterator konkretny   <br>
	*agregat   <br>
	*agregat konkretny  <br>
	</p>

	<p>
	<h3>110) Przeznaczeniem wzorca projektowego Singleton jest:  </h3>
	zapewnienie że klasa ma tylko jeden egzemplarz i zapewnia globalny dostęp do niego  <br>
	</p>

	<p>
	<h3>111) Uczestnikami wzorca projektowego Singleton są:  </h3>
	singleton  <br>
	</p>

	<p>
	<h3>112) Przeznaczeniem wzorca projektowego Fabryka abstrakcyjna jest:  </h3>
	udostępnienie interfejsu do tworzenia rodzin powiązanych ze sobą lub zależnych od siebie obiektów bez określania ich klas konkrentych <br>
	</p>

	<p>
	<h3>113) Uczestnikami wzorca projektowego Fabryka abstrakcyjna są:  </h3>
	*abstrakcyjna Fabryka  <br>
	*konkrentaFabryka  <br>
	*abstrakcyjny Produkt  <br>
	*konkretny produkt  <br>
	*klient  <br>
	</p>

	<p>
	<h3>114) Przeznaczeniem wzorca projektowego Metoda wytwórcza jest:  </h3>
	określenie interfejsu do tworzenia obiektów, przy czym umożliwia podklasom wyznaczanie klasy danego obiektu. Umożliwia klasom przekazanie procesu tworzenia egzemplarzy podklasom  <br>
	</p>

	<p>
	<h3>115) Uczestnikami wzorca projektowego Metoda wytwórcza są:  </h3>
	*produkt  <br>
	*konkretny produkt  <br>
	*kreator  <br>
	*konkretnyKreator  <br>
	</p>

	<p>
	<h3>116) Wzorzec Model-Widok-Kontroler zaliczany jest do grupy wzorców:  </h3>
	architektonicznych  <br>
	</p>

	<p>
	<h3>117) We wzorcu Model-Widok-Kontroler wykorzystuje się wzorce: </h3>
	architektury   <br>
	</p>

	<p>
	<h3>118) Dobry test to taki, który:  </h3>
	z dużym prawdopodobieństwem pozwala znaleźć błąd wcześniej nie wykryty  <br>
	</p>

	<p>
	<h3>119) Istotą testowania oprogramowania jest:  </h3>
	wykrywanie błędów.  <br>
	operatywność; obserwowalność; sterowność; podzielność; prostota; stabilność; zrozumiałość   <br>
	</p>

	<p>
	<h3>120) Weryfikacja systemu oznacza sprawdzenie:  </h3>
	czy system został zbudowany dobrze  <br>
	</p>

	<p>
	<h3>121) Walidacja systemu oznacza sprawdzenie:  </h3>
	czy zbudowany został dobry system  <br>
	</p>

	<p>
	<h3>122) Statyczna weryfikacja systemu oznacza:  </h3>
	testowanie przed uruchomieniem systemu. Związane z analizą statycznej reprezentacji systemu w celu wykrycia błędów  <br>
	</p>

	<p>
	<h3>123) Aksjomat antyekstensjonalności oznacza, że:  </h3>
	zestaw testów pokrywający jedną implementacje danej specyfikacji nie musi pokrywać jej innej implementacji. Dwie klasy mogą być takie same, ale mogą różnić się metodami i test może być mylny  <br>
	</p>

	<p>
	<h3>124) Aksjomat antydekompozycji oznacza, że:  </h3>
	zestaw testów z których każdy osobno jest adekwatny dla segmentów w module, zawsze są odpowiednie dla modułu jako całości  <br>
	</p>

	<p>
	<h3>125) Aksjomat antykompozycji oznacza, że: </h3>
	zestaw testów z których każdy osobno jest adekwatny dla segmentów w module, niekoniecznie są odpowiednie dla modułu jako całości   <br>
	</p>

	<p>
	<h3>126) Analizując pokrycie kodu, pokrycie instrukcji oznacza, że:  </h3>
	każda instrukcja jest sprawdzana  <br>
	</p>

	<p>
	<h3>127) W analizie pokrycie kodu, pokrycie gałęzi oznacza, że: </h3>
	każda gałąź jest odwiedzona, czyli instrukcja warunkowa musi być testowana naprawdę i fałsz   <br>
	</p>

	<p>
	<h3>128) Testowanie regresyjne oznacza:  ponowne wykonanie opracowanych wcześniej testów</h3>
	testowanie wewnętrznej struktury programy (white box testing) testy jednostkowe oraz integracyjne <br>
	</p>

	<p>
	<h3>130) Testy czarnej skrzynki:  </h3>
	nie biorą pod uwagę wewnętrznej struktury programu, wszystkie rodzaje testowania  <br>
	</p>

	<p>
	<h3>131) Inspekcje oprogramowania polegają na:  </h3>
	przeglądaniu źródłowej reprezentacji systemu i szukaniu błędów. Sprawdzane są artefakty celem wykrycia anomalii.   <br>
	</p>

	<p>
	<h3>132) Proces pre-processingu testu oznacza:  </h3>
	że system jest ustawiany w stan testu  <br>
	</p>

	<p>
	<h3>133) Proces post-processingu testu oznacza: </h3>
	system jest przywracany do użytkowania po testowaniu, trwa sprzątanie w systemie   <br>
	</p>

	<p>
	<h3>134) Makro CPPUNIT_ASSERT_EQUAL(a, b) z biblioteki CppUnit umożliwia:  </h3>
	testowanie czy A jest równe B  <br>
	</p>

	<p>
	<h3>135) Makro CPPUNIT_ASSERT(a) z biblioteki CppUnit umożliwia:  </h3>
	testowanie warunku A, jeśli warunek A nie jest spełniony, to test nie jest zaliczony  <br>
	</p>

	<p>
	<h3>136) Makro CPPUNIT_ASSERT_THROW(a, b) z biblioteki CppUnit umożliwia:  </h3>
	testowanie parametru A, jeśli dla wyrażenia A zostanie zgłoszony wyjątek B to test zostanie zaliczony  <br>
	</p>

	<p>
	<h3>137) W przypadku pisania testów jednostkowych należy:  </h3>
	*unikać wpisywania na sztywno ścieżek dostępu do zasobów  <br>
	*uniezależnić testy od czasu, lokalizacji…  <br>
	*wprowadzić obsługę wyjątków  <br>
	*zakładać, że przypadki testowe są wykonywane w dowolnej kolejności  <br>
	*unikać pisania przypadków testowych z efektami ubocznymi  <br>
	*testować prywatne metody  <br>
	setUp() <br>
	P- poor quality (słaba jakość) <br>
	</p>

	<p>
	<h3>140) Proces CMM jest procesem:  </h3>
	służącym ocenie procesu wytwórczego służącego do produkcji oprogramowania. CMM ocenia praktyki stosowane podczas produkcji. Model ocenia proces w skali pięciostopniowej.  <br>
	</p>

	<p>
	<h3>141) Programowanie Ekstremalne jest procesem: </h3>
	lekkim – metodyka rozwoju oprogramowania  1990 Kent Beck   <br>
	</p>

	<p>
	<h3>142) W metodach lekkich wytwarzania oprogramowania: </h3>
	*jednostki i interakcje niż procesy i narzędzia, czyli ewidentnie sprzeciwiają się podejściom zorientowanym  <br>
	*na procedury i dyscyplinę  <br>
	*działające oprogramowanie niż obszerna dokumentacja – stawiają na jakość produktu końcowego  <br>
	*współpraca klienta niż negocjacja kontraktu <br>
	* nadążanie za zmianami niż trzymanie się planu  <br>
	</p>

	<p>
	<h3>143) W Programowaniu Ekstremalnym pojedynczy przyrost oprogramowania:  </h3>
	*czas: 2-3 tygodnie  <br>
	*charakter wewnętrzny  <br>
	*niepusty zbiór opowieści użytkownika  <br>
	</p>

	<p>
	<h3>144) W Programowaniu Ekstremalnym pojedyncze wydanie programu:  </h3>
	*ma wartość użytkową  <br>
	*trafia do użytkownika końcowego  <br>
	</p>

	<p>
	<h3>145) Sposobem zapewnienia wysokiej jakości programu tworzonego zgodnie z Programowaniem Ekstremalnym jest:  </h3>
	*dbanie o prostotę  <br>
	*unikanie optymalizacji  <br>
	*dla każdej jednostki kodu opracuj najpierw zestaw testów  <br>
	*automatyczne wykonanie testów *refaktoryzacja  <br>
	</p>

	<p>
	<h3>146) Sposobem zapewnienia wysokiej jakości programu tworzonego zgodnie z Programowaniem Ekstremalnym jest:  </h3>
	*program musi przejść wszystkie testy jednostkowe zanim przekazany będzie do eksploatacji  <br>
	*dla każdego błędu tworzony nowy zestaw testów  <br>
	*często integrować kod  <br>
	*często wykonywać testy akceptacyjne i publikować wyniki  <br>
	</p>

	<p>
	<h3>147) W Programowaniu Ekstremalnym programowanie parami oznacza, że:  </h3>
	*cały kod jest programowany w parach  <br>
	*jest to standard kodowania  <br>
	*tylko jedna para integruje kod w danej chwili  <br>
	*pary zmieniają się   <br>
	*otwarta przestrzeń dla zespołu  <br>
	</p>

	<p>
	<h3>148) Inżynieria ponowna to: </h3>
	proces transformacji istniejącego oprogramowania w celu poprawy jego pielęgnowalności.    <br>
	działania programu (obserwowalnego zachowania) <br>
	</p>


</body>
</html>
